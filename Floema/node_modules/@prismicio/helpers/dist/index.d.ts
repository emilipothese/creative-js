import * as _prismicio_types from '@prismicio/types';
import { DateField, TimestampField, FilledLinkToDocumentField, LinkField, PrismicDocument, RichTextField, TitleField, ImageFieldImage, ImageField, AnyRegularField, Slice, SharedSlice, LinkToMediaField, ColorField, NumberField, KeyTextField, GeoPointField } from '@prismicio/types';
import { RichTextFunctionSerializer, RichTextMapSerializer, RichTextMapSerializerFunction } from '@prismicio/richtext';
export { Element } from '@prismicio/richtext';

/**
 * Transforms a date or timestamp field into a JavaScript Date object
 *
 * @param dateOrTimestampField - A date or timestamp field from Prismic
 *
 * @returns A Date object, null if provided date is falsy
 * @see Templating date field from Prismic {@link https://prismic.io/docs/technologies/templating-date-field-javascript}
 */
declare const asDate: (dateOrTimestampField: DateField | TimestampField) => Date | null;

/**
 * Resolves a link to a Prismic document to a URL
 *
 * @typeParam ReturnType - Return type of your link resolver function, useful if
 *   you prefer to return a complex object
 * @param linkToDocumentField - A document link field to resolve
 *
 * @returns Resolved URL
 * @see Prismic link resolver documentation: {@link https://prismic.io/docs/technologies/link-resolver-javascript}
 */
declare type LinkResolverFunction<ReturnType = string> = (linkToDocumentField: Omit<FilledLinkToDocumentField, "url">) => ReturnType;
/**
 * Serializes a node from a rich text or title field with a function to HTML
 *
 * Unlike a typical `@prismicio/richtext` function serializer, this serializer
 * converts the `children` argument to a single string rather than an array of strings.
 *
 * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}
 */
declare type HTMLFunctionSerializer = (type: Parameters<RichTextFunctionSerializer<string>>[0], node: Parameters<RichTextFunctionSerializer<string>>[1], text: Parameters<RichTextFunctionSerializer<string>>[2], children: Parameters<RichTextFunctionSerializer<string>>[3][number], key: Parameters<RichTextFunctionSerializer<string>>[4]) => string | null | undefined;
/**
 * Serializes a node from a rich text or title field with a map to HTML
 *
 * Unlike a typical `@prismicio/richtext` map serializer, this serializer
 * converts the `children` property to a single string rather than an array of strings.
 *
 * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}
 */
declare type HTMLMapSerializer = {
    [P in keyof RichTextMapSerializer<string>]: (payload: {
        type: Parameters<HTMLMapSerializerFunction<P>>[0]["type"];
        node: Parameters<HTMLMapSerializerFunction<P>>[0]["node"];
        text: Parameters<HTMLMapSerializerFunction<P>>[0]["text"];
        children: Parameters<HTMLMapSerializerFunction<P>>[0]["children"][number];
        key: Parameters<HTMLMapSerializerFunction<P>>[0]["key"];
    }) => string | null | undefined;
};
/**
 * A {@link RichTextMapSerializerFunction} type specifically for {@link HTMLMapSerializer}.
 *
 * @typeParam BlockName - The serializer's Rich Text block type.
 */
declare type HTMLMapSerializerFunction<BlockType extends keyof RichTextMapSerializer<string>> = RichTextMapSerializerFunction<string, ExtractNodeGeneric<RichTextMapSerializer<string>[BlockType]>, ExtractTextTypeGeneric<RichTextMapSerializer<string>[BlockType]>>;
/**
 * Returns the `Node` generic from {@link RichTextMapSerializerFunction}.
 *
 * @typeParam T - The `RichTextMapSerializerFunction` containing the needed
 *   `Node` generic.
 */
declare type ExtractNodeGeneric<T> = T extends RichTextMapSerializerFunction<any, infer U, any> ? U : never;
/**
 * Returns the `TextType` generic from {@link RichTextMapSerializerFunction}.
 *
 * @typeParam T - The `RichTextMapSerializerFunction` containing the needed
 *   `TextType` generic.
 */
declare type ExtractTextTypeGeneric<T> = T extends RichTextMapSerializerFunction<any, any, infer U> ? U : never;

/**
 * Resolves any type of link field or document to a URL
 *
 * @typeParam LinkResolverFunctionReturnType - Link resolver function return type
 * @param linkFieldOrDocument - Any kind of link field or a document to resolve
 * @param linkResolver - An optional link resolver function, without it you're
 *   expected to use the `routes` options from the API
 *
 * @returns Resolved URL, null if provided link is empty
 * @see Prismic link resolver documentation: {@link https://prismic.io/docs/technologies/link-resolver-javascript}
 * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/technologies/route-resolver-nuxtjs}
 */
declare const asLink: <LinkResolverFunctionReturnType = string>(linkFieldOrDocument: LinkField | PrismicDocument, linkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null | undefined) => string | LinkResolverFunctionReturnType | null;

/**
 * Serializes a rich text or title field to a plain text string
 *
 * @param richTextField - A rich text or title field from Prismic
 * @param separator - Separator used to join each element, defaults to a space
 *
 * @returns Plain text equivalent of the provided rich text or title field
 * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}
 */
declare const asText: (richTextField: RichTextField | null | undefined, separator?: string | undefined) => string | null;

/**
 * Serializes a rich text or title field to an HTML string
 *
 * @param richTextField - A rich text or title field from Prismic
 * @param linkResolver - An optional link resolver function to resolve links,
 *   without it you're expected to use the `routes` options from the API
 * @param htmlSerializer - An optional serializer, unhandled cases will fallback
 *   to the default serializer
 *
 * @returns HTML equivalent of the provided rich text or title field
 * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}
 */
declare const asHTML: (richTextField: RichTextField | null | undefined, linkResolver?: LinkResolverFunction<string> | null | undefined, htmlSerializer?: HTMLMapSerializer | HTMLFunctionSerializer | null | undefined) => string | null;

/**
 * Determines if a Rich Text field is filled.
 *
 * @param field - Rich Text field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const richText: (field: RichTextField) => field is [_prismicio_types.RTNode, ..._prismicio_types.RTNode[]];
/**
 * Determines if a Title field is filled.
 *
 * @param field - Title field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const title: (field: TitleField) => field is [Omit<_prismicio_types.RTHeading1Node | _prismicio_types.RTHeading2Node | _prismicio_types.RTHeading3Node | _prismicio_types.RTHeading4Node | _prismicio_types.RTHeading5Node | _prismicio_types.RTHeading6Node, "spans"> & {
    spans: [];
}];
/**
 * Determines if an Image thumbnail is filled.
 *
 * @param field - Image thumbnail to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const imageThumbnail: (thumbnail: ImageFieldImage) => thumbnail is _prismicio_types.FilledImageFieldImage;
/**
 * Determines if an Image field is filled.
 *
 * @param field - Image field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const image: <ThumbnailNames extends string>(field: ImageField<ThumbnailNames, _prismicio_types.FieldState>) => field is ImageField<ThumbnailNames, "filled">;
/**
 * Determines if a Link field is filled.
 *
 * @param field - Link field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const link: <TypeEnum = string, LangEnum = string, DataInterface extends Record<string, AnyRegularField | [Record<string, AnyRegularField>, ...Record<string, AnyRegularField>[]] | [Slice<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>> | SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>>>, ...(Slice<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>> | SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>>>)[]]> = never>(field: _prismicio_types.EmptyLinkField<"Any"> | _prismicio_types.FilledLinkToWebField | _prismicio_types.FilledLinkToMediaField | _prismicio_types.FilledLinkToDocumentField<TypeEnum, LangEnum, DataInterface>) => field is _prismicio_types.FilledLinkToWebField | _prismicio_types.FilledLinkToMediaField | _prismicio_types.FilledLinkToDocumentField<TypeEnum, LangEnum, DataInterface>;
/**
 * Determines if a Link to Media field is filled.
 *
 * @param field - Link to Media field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const linkToMedia: (field: LinkToMediaField) => field is _prismicio_types.FilledLinkToMediaField;
/**
 * Determines if a Content Relationship field is filled.
 *
 * @param field - Content Relationship field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const contentRelationship: <TypeEnum = string, LangEnum = string, DataInterface extends Record<string, AnyRegularField | [Record<string, AnyRegularField>, ...Record<string, AnyRegularField>[]] | [Slice<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>> | SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>>>, ...(Slice<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>> | SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>>>)[]]> = never>(field: _prismicio_types.EmptyLinkField<"Document"> | _prismicio_types.FilledLinkToDocumentField<TypeEnum, LangEnum, DataInterface>) => field is _prismicio_types.FilledLinkToDocumentField<TypeEnum, LangEnum, DataInterface>;
/**
 * Determines if a Date field is filled.
 *
 * @param field - Date field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const date: (field: DateField) => field is `${number}-${number}-${number}`;
/**
 * Determines if a Timestamp field is filled.
 *
 * @param field - Timestamp field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const timestamp: (field: TimestampField) => field is `${number}-${number}-${number}T${number}:${number}:${number}+${number}`;
/**
 * Determines if a Color field is filled.
 *
 * @param field - Color field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const color: (field: ColorField) => field is `#${string}`;
/**
 * Determines if a Number field is filled.
 *
 * @param field - Number field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const number: (field: NumberField) => field is number;
/**
 * Determines if a Key Text field is filled.
 *
 * @param field - Key Text field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const keyText: (field: KeyTextField) => field is string;
/**
 * Determines if a Select field is filled.
 *
 * @param field - Select field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const select: <Enum extends string>(field: Enum | null) => field is Enum;
/**
 * Determines if an Embed field is filled.
 *
 * @param field - Embed field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const embed: <Data extends Record<string, unknown>>(field: {
    [x: string]: never;
} | ({
    embed_url: string;
    type: "link" | "rich";
} & Data)) => field is {
    embed_url: string;
    type: "link" | "rich";
} & Data;
/**
 * Determines if a GeoPoint field is filled.
 *
 * @param field - GeoPoint field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const geoPoint: (field: GeoPointField) => field is {
    latitude: number;
    longitude: number;
};
/**
 * Determines if an Integration Fields field is filled.
 *
 * @param field - Integration Fields field to check.
 *
 * @returns `true` if `field` is filled, `false` otherwise.
 */
declare const integrationFields: <Blob_1>(field: {
    id: string;
    title?: string | undefined;
    description?: string | undefined;
    image_url?: string | undefined;
    last_update: number;
    blob: Blob_1;
} | null) => field is {
    id: string;
    title?: string | undefined;
    description?: string | undefined;
    image_url?: string | undefined;
    last_update: number;
    blob: Blob_1;
};
/**
 * Determines if a Group has at least one item.
 *
 * @param group - Group to check.
 *
 * @returns `true` if `group` contains at least one item, `false` otherwise.
 */
declare const group: <Fields extends Record<string, AnyRegularField>>(group: [] | [Fields, ...Fields[]]) => group is [Fields, ...Fields[]];
/**
 * Determines if a Slice Zone has at least one Slice.
 *
 * @param slices - Slice Zone to check.
 *
 * @returns `true` if `slices` contains at least one Slice, `false` otherwise.
 */
declare const sliceZone: <Slices extends Slice<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>> | SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, AnyRegularField>, Record<string, AnyRegularField>>>>(slices: [] | [Slices, ...Slices[]]) => slices is [Slices, ...Slices[]];

declare const isFilled_richText: typeof richText;
declare const isFilled_title: typeof title;
declare const isFilled_imageThumbnail: typeof imageThumbnail;
declare const isFilled_image: typeof image;
declare const isFilled_link: typeof link;
declare const isFilled_linkToMedia: typeof linkToMedia;
declare const isFilled_contentRelationship: typeof contentRelationship;
declare const isFilled_date: typeof date;
declare const isFilled_timestamp: typeof timestamp;
declare const isFilled_color: typeof color;
declare const isFilled_number: typeof number;
declare const isFilled_keyText: typeof keyText;
declare const isFilled_select: typeof select;
declare const isFilled_embed: typeof embed;
declare const isFilled_geoPoint: typeof geoPoint;
declare const isFilled_integrationFields: typeof integrationFields;
declare const isFilled_group: typeof group;
declare const isFilled_sliceZone: typeof sliceZone;
declare namespace isFilled {
  export {
    isFilled_richText as richText,
    isFilled_title as title,
    isFilled_imageThumbnail as imageThumbnail,
    isFilled_image as image,
    isFilled_link as link,
    isFilled_linkToMedia as linkToMedia,
    isFilled_contentRelationship as contentRelationship,
    isFilled_date as date,
    isFilled_timestamp as timestamp,
    isFilled_color as color,
    isFilled_number as number,
    isFilled_keyText as keyText,
    isFilled_select as select,
    isFilled_embed as embed,
    isFilled_geoPoint as geoPoint,
    isFilled_integrationFields as integrationFields,
    isFilled_group as group,
    isFilled_sliceZone as sliceZone,
  };
}

declare type SetOptional<T, Keys extends keyof T> = Omit<T, Keys> & Partial<Pick<T, Keys>>;
/**
 * Converts a document into a link field, this is useful when crawling the API
 * for document links
 *
 * @typeParam TDocument - Specific interface of the provided document
 * @param prismicDocument - A document coming from Prismic
 *
 * @returns The equivalent link field to use with `asLink()`
 * @internal
 */
declare const documentToLinkField: <TDocument extends SetOptional<PrismicDocument<Record<string, _prismicio_types.AnyRegularField | [Record<string, _prismicio_types.AnyRegularField>, ...Record<string, _prismicio_types.AnyRegularField>[]] | [_prismicio_types.Slice<string, Record<string, _prismicio_types.AnyRegularField>, Record<string, _prismicio_types.AnyRegularField>> | _prismicio_types.SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, _prismicio_types.AnyRegularField>, Record<string, _prismicio_types.AnyRegularField>>>, ...(_prismicio_types.Slice<string, Record<string, _prismicio_types.AnyRegularField>, Record<string, _prismicio_types.AnyRegularField>> | _prismicio_types.SharedSlice<string, _prismicio_types.SharedSliceVariation<string, Record<string, _prismicio_types.AnyRegularField>, Record<string, _prismicio_types.AnyRegularField>>>)[]]>, string, string>, "slugs">>(prismicDocument: TDocument) => FilledLinkToDocumentField<TDocument["type"], TDocument["lang"], TDocument["data"]>;

/**
 * @deprecated Renamed to `Element` (without an "s").
 */
declare const Elements: {
    readonly heading1: "heading1";
    readonly heading2: "heading2";
    readonly heading3: "heading3";
    readonly heading4: "heading4";
    readonly heading5: "heading5";
    readonly heading6: "heading6";
    readonly paragraph: "paragraph";
    readonly preformatted: "preformatted";
    readonly strong: "strong";
    readonly em: "em";
    readonly listItem: "list-item";
    readonly oListItem: "o-list-item";
    readonly list: "group-list-item";
    readonly oList: "group-o-list-item";
    readonly image: "image";
    readonly embed: "embed";
    readonly hyperlink: "hyperlink";
    readonly label: "label";
    readonly span: "span";
};

export { Elements, HTMLFunctionSerializer, HTMLMapSerializer, LinkResolverFunction, asDate, asHTML, asLink, asText, documentToLinkField, isFilled };
